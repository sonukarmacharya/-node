import { TwingErrorRuntime } from "./error/runtime";
import { TwingSource } from "./source";
import { TwingEnvironment } from "./environment";
import { TwingExtensionInterface } from "./extension-interface";
import { TwingContext } from "./context";
import { TwingMarkup } from "./markup";
import { TwingSandboxSecurityError } from "./sandbox/security-error";
import { TwingSandboxSecurityNotAllowedFilterError } from "./sandbox/security-not-allowed-filter-error";
import { TwingSandboxSecurityNotAllowedFunctionError } from "./sandbox/security-not-allowed-function-error";
import { TwingSandboxSecurityNotAllowedTagError } from "./sandbox/security-not-allowed-tag-error";
import { IterateCallback } from "./helpers/iterate";
declare type TwingTemplateMacrosMap = Map<string, TwingTemplateMacroHandler>;
declare type TwingTemplateAliasesMap = TwingContext<string, TwingTemplate>;
declare type TwingTemplateTraceableMethod<T> = (...args: Array<any>) => Promise<T>;
export declare type TwingTemplateBlocksMap = Map<string, [TwingTemplate, string]>;
export declare type TwingTemplateBlockHandler = (context: any, blocks: TwingTemplateBlocksMap) => Promise<void>;
export declare type TwingTemplateMacroHandler = (...args: Array<any>) => Promise<string>;
/**
 * Default base class for compiled templates.
 *
 * @author Eric MORAND <eric.morand@gmail.com>
 */
export declare abstract class TwingTemplate {
    static ANY_CALL: string;
    static ARRAY_CALL: string;
    static METHOD_CALL: string;
    protected parent: TwingTemplate | false;
    protected parents: Map<TwingTemplate | string, TwingTemplate>;
    protected env: TwingEnvironment;
    protected blocks: TwingTemplateBlocksMap;
    protected blockHandlers: Map<string, TwingTemplateBlockHandler>;
    protected macroHandlers: Map<string, TwingTemplateMacroHandler>;
    protected traits: TwingTemplateBlocksMap;
    protected macros: TwingTemplateMacrosMap;
    protected aliases: TwingTemplateAliasesMap;
    protected extensions: Map<string, TwingExtensionInterface>;
    protected sourceContext: TwingSource;
    constructor(env: TwingEnvironment);
    /**
     * Returns the template name.
     *
     * @returns {string} The template name
     */
    getTemplateName(): string;
    /**
     * @returns {TwingSource}
     */
    getSourceContext(): TwingSource;
    /**
     * Returns the parent template.
     *
     * @param {any} context
     *
     * @returns {Promise<TwingTemplate|false>} The parent template or false if there is no parent
     */
    getParent(context?: any): Promise<TwingTemplate | false>;
    /**
     * Returns template blocks.
     *
     * @returns {Promise<TwingTemplateBlocksMap>} A map of blocks
     */
    getBlocks(): Promise<TwingTemplateBlocksMap>;
    isTraitable(): boolean;
    /**
     * Displays a block.
     *
     * @param {string} name The block name to display
     * @param {any} context The context
     * @param {TwingTemplateBlocksMap} blocks The active set of blocks
     * @param {boolean} useBlocks Whether to use the active set of blocks
     *
     * @returns {Promise<void>}
     */
    protected displayBlock(name: string, context: any, blocks?: TwingTemplateBlocksMap, useBlocks?: boolean): Promise<void>;
    /**
     * Displays a parent block.
     *
     * @param {string} name The block name to display from the parent
     * @param {any} context The context
     * @param {TwingTemplateBlocksMap} blocks The active set of blocks
     *
     * @returns {Promise<void>}
     */
    protected displayParentBlock(name: string, context: any, blocks: TwingTemplateBlocksMap): Promise<void>;
    /**
     * Renders a parent block.
     *
     * @param {string} name The block name to display from the parent
     * @param {*} context The context
     * @param {TwingTemplateBlocksMap} blocks The active set of blocks
     *
     * @returns {Promise<string>} The rendered block
     */
    protected renderParentBlock(name: string, context: any, blocks: TwingTemplateBlocksMap): Promise<string>;
    /**
     * Renders a block.
     *
     * @param {string} name The block name to display
     * @param context The context
     * @param {TwingTemplateBlocksMap} blocks The active set of blocks
     * @param {boolean} useBlocks Whether to use the active set of blocks
     *
     * @return {Promise<string>} The rendered block
     */
    protected renderBlock(name: string, context: any, blocks?: TwingTemplateBlocksMap, useBlocks?: boolean): Promise<string>;
    /**
     * Returns whether a block exists or not in the active context of the template.
     *
     * This method checks blocks defined in the active template or defined in "used" traits or defined in parent templates.
     *
     * @param {string} name The block name
     * @param {any} context The context
     * @param {TwingTemplateBlocksMap} blocks The active set of blocks
     *
     * @return {Promise<boolean>} true if the block exists, false otherwise
     */
    hasBlock(name: string, context: any, blocks?: TwingTemplateBlocksMap): Promise<boolean>;
    /**
     * @param {string} name The macro name
     *
     * @return {Promise<boolean>}
     */
    hasMacro(name: string): Promise<boolean>;
    loadTemplate(templates: TwingTemplate | Map<number, TwingTemplate> | string, line?: number, index?: number): Promise<TwingTemplate>;
    /**
     * Returns template traits.
     *
     * @returns {Promise<TwingTemplateBlocksMap>} A map of traits
     */
    getTraits(): Promise<TwingTemplateBlocksMap>;
    protected doGetTraits(): Promise<TwingTemplateBlocksMap>;
    display(context: any, blocks?: TwingTemplateBlocksMap): Promise<void>;
    protected displayWithErrorHandling(context: any, blocks?: TwingTemplateBlocksMap): Promise<void>;
    render(context: any): Promise<string>;
    /**
     * Auto-generated method to display the template with the given context.
     *
     * @param {any} context An array of parameters to pass to the template
     * @param {TwingTemplateBlocksMap} blocks
     */
    protected abstract doDisplay(context: any, blocks: TwingTemplateBlocksMap): Promise<void>;
    protected doGetParent(context: any): Promise<TwingTemplate | string | false>;
    protected callMacro(template: TwingTemplate, name: string, args: any[], lineno: number, context: TwingContext<any, any>, source: TwingSource): Promise<string>;
    traceableMethod<T>(method: Function, lineno: number, source: TwingSource): TwingTemplateTraceableMethod<T>;
    traceableDisplayBlock(lineno: number, source: TwingSource): TwingTemplateTraceableMethod<void>;
    traceableDisplayParentBlock(lineno: number, source: TwingSource): TwingTemplateTraceableMethod<void>;
    traceableRenderBlock(lineno: number, source: TwingSource): TwingTemplateTraceableMethod<string>;
    traceableRenderParentBlock(lineno: number, source: TwingSource): TwingTemplateTraceableMethod<string>;
    traceableHasBlock(lineno: number, source: TwingSource): TwingTemplateTraceableMethod<boolean>;
    protected readonly cloneMap: <K, V>(m: Map<K, V>) => Map<K, V>;
    protected readonly compare: (a: any, b: any) => boolean;
    protected readonly constant: (env: TwingEnvironment, name: string, object: any) => any;
    protected readonly convertToMap: (iterable: any) => Map<any, any>;
    protected readonly count: (a: any) => number;
    protected readonly createRange: (low: any, high: any, step: number) => Map<number, any>;
    protected readonly echo: (value: any) => void;
    protected readonly endAndCleanOutputBuffer: () => boolean;
    protected readonly ensureTraversable: <T>(candidate: T[]) => T[] | [];
    protected readonly flushOutputBuffer: () => void;
    protected readonly get: (object: any, property: any) => any;
    protected readonly getAndCleanOutputBuffer: () => string | false;
    protected readonly getAttribute: (env: TwingEnvironment, object: any, item: any, _arguments: Map<any, any>, type: string, isDefinedTest: boolean, ignoreStrictCheck: boolean, sandboxed: boolean) => any;
    protected readonly getOutputBufferContent: () => string | false;
    protected readonly include: (context: any, from: TwingSource, templates: string | Map<number, string | TwingTemplate> | TwingTemplate, variables: any, withContext: boolean, ignoreMissing: boolean, line: number) => Promise<string>;
    protected readonly isCountable: (candidate: any) => boolean;
    protected readonly isIn: (a: any, b: any) => boolean;
    protected concatenate(object1: any, object2: any): string;
    protected readonly iterate: (it: any, cb: IterateCallback) => Promise<void>;
    protected readonly merge: <V>(iterable1: Map<any, V>, iterable2: Map<any, V>) => Map<any, V>;
    protected readonly parseRegExp: (input: string) => RegExp;
    protected readonly startOutputBuffer: () => boolean;
    protected readonly Context: typeof TwingContext;
    protected readonly Markup: typeof TwingMarkup;
    protected readonly RuntimeError: typeof TwingErrorRuntime;
    protected readonly SandboxSecurityError: typeof TwingSandboxSecurityError;
    protected readonly SandboxSecurityNotAllowedFilterError: typeof TwingSandboxSecurityNotAllowedFilterError;
    protected readonly SandboxSecurityNotAllowedFunctionError: typeof TwingSandboxSecurityNotAllowedFunctionError;
    protected readonly SandboxSecurityNotAllowedTagError: typeof TwingSandboxSecurityNotAllowedTagError;
    protected readonly Source: typeof TwingSource;
}
export {};
